### 2
- 按行序：
[-1,1,1,-2] [-1,1,1,-1] [-1,1,2,-2] [-1,1,2,-1] [-1,1,3,-2] [-1,1,3,-1] [-1,2,1,-2] [-1,2,1,-1] [-1,2,2,-2] [-1,2,2,-1] [-1,2,3,-2] [-1,2,3,-1] [0,1,1,-2] [0,1,1,-1] [0,1,2,-2] [0,1,2,-1] [0,1,3,-2] [0,1,3,-1] [0,2,1,-2] [0,2,1,-1] [0,2,2,-2] [0,2,2,-1] [0,2,3,-2] [0,2,3,-1]
- 按列序：
[-1,1,1,-2] [0,1,1,-2] [-1,2,1,-2] [0,2,1,-2] [-1,1,2,-2] [0,1,2,-2] [-1,2,2,-2] [0,2,2,-2] [-1,1,3,-2] [0,1,3,-2] [-1,2,3,-2] [0,2,3,-2] [-1,1,1,-1] [0,1,1,-1] [-1,2,1,-1] [0,2,1,-1] [-1,1,2,-1] [0,1,2,-1] [-1,2,2,-1] [0,2,2,-1] [-1,1,3,-1] [0,1,3,-1] [-1,2,3,-1] [0,2,3,-1]

### 3
- 按行存储：16 
- 按列存储：12

### 4
设n维数组每维下标变化范围分别为闭区间[li,hi](1 <= i <= n)，每个元素所占单元数目为c,函数为(a为每个闭区间的li，hi，n、c如上所述，element数组为元素每一维的下标)：
```cpp
int address(T a[], int c, int n, int element[]) {
    int dep = 0, ans = 1;
    for (int i = n; i >= 1; i--) {
        ans += dep * (a[element[i]] - a[i].li);
        dep *= (a[i].ri - a[i].li + 1) 
    }
    return ans * c;
}
```

### 5
按行存储：
Loc(i, j) = ((j - l1)(2n - j + l2 + 1)/2 + i - l2 + j - l1) * c * c ....... i <= j
Loc(i, j) = Loc(j, i) ............................ i > j

按列存储：
Loc(i, j) = ((j - l2)(i - l2 + 1) / 2 +(i - l1)) * c ... i <= j
Loc(i, j) = Loc(j, i) .................................. i > j